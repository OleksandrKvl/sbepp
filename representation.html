<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sbepp: Schema representation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sbepp<span id="projectnumber">&#160;1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('representation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Schema representation</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md13">Representation types vs. traits</a></li>
<li class="level1"><a href="#autotoc_md15">Namespaces</a></li>
<li class="level1"><a href="#autotoc_md17">Schema names</a></li>
<li class="level1"><a href="#autotoc_md19">Semantics</a><ul><li class="level2"><a href="#autotoc_md20">Safety checks</a></li>
<li class="level2"><a href="#autotoc_md21">Encoding vs. decoding</a></li>
</ul>
</li>
<li class="level1"><a href="#messages">Messages</a><ul><li class="level2"><a href="#encoding-message">Encoding</a></li>
</ul>
</li>
<li class="level1"><a href="#composites">Composites</a></li>
<li class="level1"><a href="#groups">Groups</a><ul><li class="level2"><a href="#autotoc_md25">Encoding</a></li>
<li class="level2"><a href="#autotoc_md26">Group entries</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md28">Data members</a></li>
<li class="level1"><a href="#autotoc_md30">Fixed-size arrays</a></li>
<li class="level1"><a href="#non-array-types">Optional/required types</a></li>
<li class="level1"><a href="#enums">Enums</a></li>
<li class="level1"><a href="#sets">Sets</a></li>
<li class="level1"><a href="#constants">Constants</a></li>
<li class="level1"><a href="#accessors">Field accessors</a></li>
<li class="level1"><a href="#cursor-accessors">Cursor-based accessors</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2sbepp_2sbepp_2doc_2representation"></a></p>
<p>In this section I'll try to gradually describe the structure of generated code. It's just a brief description, for detailed documentation see corresponding reference pages.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Representation types vs. traits</h1>
<p>For each schema compiled by <code>sbeppc</code>, there will be two main sources of information:</p><ul>
<li>representation types, responsible for the actual SBE data encoding/decoding and proper representation of schema entities. Except constants, all the information they provide comes from binary data. These are described in more details below on this page.</li>
<li><a class="el" href="traits.html">traits</a>, in combination with tags, they provide access to static/meta schema properties that, unlike representation types, always come from precomputed values obtained from schema XML.</li>
</ul>
<p>Sometimes, traits and representation types have functionality with common names, but it's very different in nature. For example, <code><a class="el" href="classsbepp_1_1message__traits.html" title="Provides various traits/attributes of a &lt;message&gt; element.">sbepp::message_traits</a>&lt;msg_tag&gt;::size_bytes()</code> returns precomputed value based on message structure from the XML, and hence guaranteed to be valid only for the current schema version. On the other hand, <code>sbepp::size_bytes(msg)</code> calculates message size based on the message buffer and the values it holds, it returns valid value even for newer schema versions because message representation type correctly handles schema extension.</p>
<p>It's possible to get a representation type from a tag using <code>value_type</code> member of the traits (e.g. <code><a class="el" href="classsbepp_1_1message__traits.html" title="Provides various traits/attributes of a &lt;message&gt; element.">sbepp::message_traits</a>&lt;msg_tag&gt;::value_type</code>), and vice versa, to get a tag from a representation type using <code><a class="el" href="namespacesbepp.html#a0ddc0b9ce9e876a0ac772b4d1af64b4b" title="Shorthand for sbepp::traits_tag&lt;T&gt;::type">sbepp::traits_tag_t</a></code>. These helpers can be used to avoid explicit mentioning of both tag and representation types at the same time by deducing one from another.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md15"></a>
Namespaces</h1>
<p>Here's the structure of generated code after <a class="el" href="sbeppc.html">compilation</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>schema_name{</div>
<div class="line">    <span class="keyword">struct </span>schema{ <span class="comment">// see &quot;Traits&quot; section</span></div>
<div class="line">        <span class="keyword">struct </span>types;</div>
<div class="line">        <span class="keyword">struct </span>messages;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">namespace </span>messages{</div>
<div class="line">        <span class="comment">// messages are here...</span></div>
<div class="line">        <span class="keyword">class </span>message_name;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">namespace </span>types{</div>
<div class="line">        <span class="comment">// types are here...</span></div>
<div class="line">        <span class="keyword">class </span>type_name;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">namespace </span>detail{} <span class="comment">// implementation details, never use it directly</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Here, <code>detail</code>, <code>schema</code>, <code>messages</code> and <code>types</code> are hardcoded and don't depend on schema names.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md17"></a>
Schema names</h1>
<p><code>sbepp</code> preserves names of all schema entities without any modification. It means that messages, types, fields, etc. will have the same type/function names in the generated code. Of course standard C++ naming rules are still applied and usually you'll get an error from <code>sbeppc</code> if schema uses wrong name.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md19"></a>
Semantics</h1>
<p>Most types generated by <code>sbepp</code> have <em>reference semantics</em>. It means they are just pointers to the actual data which they don't own and don't manage in any way.</p>
<dl class="section note"><dt>Note</dt><dd>It's client's responsibility to manage the lifetime and size of the underlying buffer.</dd></dl>
<p>They usually contain a single pointer (with one additional pointer in Debug mode) and are cheap to pass by value. Creation of such an object usually invloves no actions/parsing except the pointer intialization. They are templates with <code>Byte</code> template parameter which is a byte type (can be cv-qualified). Another consequence of reference semantics is that making object <code>const</code> doesn't make underlying data <code>const</code>, i.e., you can modify a message via <code>const msg&lt;char&gt;</code> object. You need to use <code>const</code>-qualified <code>Byte</code> type to make a thing read-only. <br  />
 There are helpers to access raw underlying data which are available for all reference semantics types: <code><a class="el" href="namespacesbepp.html#a9346fd507c2d3760ac40032180d1a7a6" title="Returns the size of the underlying data represented by message/group/entry/data/composite view,...">sbepp::size_bytes</a></code>, <code><a class="el" href="namespacesbepp.html#abd9c1efb3c96d6fa71d1156811b47fa4" title="Calculate view size with additional safety checks.">sbepp::size_bytes_checked</a></code>, <code><a class="el" href="namespacesbepp.html#a870241790cb5759575b9f57d654392c2" title="Returns pointer to the underlying data referenced by a view.">sbepp::addressof</a></code>.</p>
<p><a class="el" href="#non-array-types">Non-array types</a>, <a class="el" href="#enums">enums</a> and <a class="el" href="#sets">sets</a> are the only schema entities represented with <em>value semantics</em> types (including <a class="el" href="#constants">constants</a>). They are small, 64 bits at most, types which behave like <code>int</code>.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Safety checks</h2>
<p>As was said before, client is responsible to ensure that provided buffer is enough to hold corresponding SBE data. To provide some sort of safety, <code>sbepp</code> inserts assertions in many places. They check only the accessed data, not the whole SBE message or other entity. For example, if a message has 10 fields and provided buffer can only hold 5 of them, you'll get an assertion only when any of last 5 fields will be accessed. By default, these checks are controlled by <code>NDEBUG</code> just as standard <code>assert()</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="sbepp_8hpp.html#a6a9a3e2c289e8eb83bd1937c0a54b14e" title="When defined, unconditionally disables assertions and size checks.">SBEPP_DISABLE_ASSERTS</a>, <a class="el" href="sbepp_8hpp.html#ae9a30a1ed9195270dc6dba235182ba34" title="When defined, uses client-defined sbepp::assertion_failed as an assertion handler....">SBEPP_ASSERT_HANDLER</a>, <a class="el" href="sbepp_8hpp.html#a0279553eb51c2609c3273da80e021278" title="When defined, unconditionally enables assertions. Requires sbepp::assertion_failed to be defined by t...">SBEPP_ENABLE_ASSERTS_WITH_HANDLER</a></dd></dl>
<h2><a class="anchor" id="autotoc_md21"></a>
Encoding vs. decoding</h2>
<p><code>sbepp</code> doesn't make a distinction between encoding and decoding. It only provides SBE view of the provided buffer. Functions have no hidden side-effects beyond their main functionality. The only thing which is done implicitly is handling of SBE schema extension mechanism by respecting <code>blockLength</code>. This has several consequences. First, be careful not to change things which affect the offset of the following already-written fields. For example, if you have dynamic-length fields <code>data1</code> and <code>data2</code>, don't change <code>data1</code>'s size after you filled <code>data2</code> because its offset the data will become a garbage. Simple advice is to fill groups/data fields in-order. Second, when you encode a new message, you need to explicitly fill message/group header via <code><a class="el" href="namespacesbepp.html#a3b5dd3446b423149a101530f056bee64" title="Fill message header.">sbepp::fill_message_header</a></code> or <code><a class="el" href="namespacesbepp.html#a7d29b37dfc83150ae34eaaf94dd4ba4c" title="Fill group header.">sbepp::fill_group_header</a></code> and it's better to do this as early as possible.</p>
<hr  />
<h1><a class="anchor" id="messages"></a>
Messages</h1>
<p>Messages and <a class="el" href="#composites">composites</a> are two root things from which any work with SBE data starts. Like any reference semantics type, they are created from pointer and size:</p>
<div class="fragment"><div class="line"><span class="comment">// check out base class documentation for more constructors</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Byte&gt;</div>
<div class="line"><span class="keyword">class </span>msg : <a class="code hl_class" href="classsbepp_1_1detail_1_1message__base.html">::sbepp::detail::message_base</a>&lt;Byte&gt;{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// field accessors...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::array&lt;std::byte, 64&gt; buf;</div>
<div class="line">schema_name::messages::msg&lt;std::byte&gt; m{buf.data(), buf.size()};</div>
<div class="ttc" id="aclasssbepp_1_1detail_1_1message__base_html"><div class="ttname"><a href="classsbepp_1_1detail_1_1message__base.html">sbepp::detail::message_base</a></div><div class="ttdoc">Base class for messages.</div><div class="ttdef"><b>Definition</b> sbepp.hpp:1656</div></div>
</div><!-- fragment --><p>There is a couple of helpers which deduce byte type for you, <code><a class="el" href="namespacesbepp.html#a0dda436c46165f2419bb31e450e3b5b5" title="Construct view from memory buffer.">sbepp::make_view</a></code> and <code><a class="el" href="namespacesbepp.html#ae29503045a371b895af63f6ac6e0f3b9" title="Construct read-only view from memory buffer.">sbepp::make_const_view</a></code>. They are applicable to any reference semantics type except group entry.</p>
<div class="fragment"><div class="line">std::array&lt;std::byte, 64&gt; buf;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// mutable message</span></div>
<div class="line"><span class="keyword">auto</span> m1 = sbepp::make_view&lt;schema_name::messages::msg&gt;(buf.data(), buf.size());</div>
<div class="line"><span class="comment">// read-only message</span></div>
<div class="line"><span class="keyword">auto</span> m2 =</div>
<div class="line">    sbepp::make_const_view&lt;schema_name::messages::msg&gt;(buf.data(), buf.size());</div>
</div><!-- fragment --><p>The main purpose of messages, composites and group entries is of course to contain fields, their interface will be discussed later in the <a class="el" href="#accessors">accessors</a> section.</p>
<h2><a class="anchor" id="encoding-message"></a>
Encoding</h2>
<p>Since <code>sbepp</code> provides only a message's view, message header should be filled explicitly via <code><a class="el" href="namespacesbepp.html#a3b5dd3446b423149a101530f056bee64" title="Fill message header.">sbepp::fill_message_header</a></code> when a new message is created:</p>
<div class="fragment"><div class="line">std::array&lt;std::byte, 64&gt; buf;</div>
<div class="line"><span class="keyword">auto</span> m = sbepp::make_view&lt;schema_name::messages::msg&gt;(buf.data(), buf.size());</div>
<div class="line"><a class="code hl_function" href="namespacesbepp.html#a3b5dd3446b423149a101530f056bee64">sbepp::fill_message_header</a>(m);</div>
<div class="ttc" id="anamespacesbepp_html_a3b5dd3446b423149a101530f056bee64"><div class="ttname"><a href="namespacesbepp.html#a3b5dd3446b423149a101530f056bee64">sbepp::fill_message_header</a></div><div class="ttdeci">constexpr auto fill_message_header(Message m) noexcept -&gt; decltype(m(detail::fill_message_header_tag{}))</div><div class="ttdoc">Fill message header.</div><div class="ttdef"><b>Definition</b> sbepp.hpp:3633</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It's strongly recommended to fill message header as early as possible because its <code>blockLength</code> is required to correctly interpret underlying data.</dd></dl>
<p>You can also fill it by hand using <code><a class="el" href="namespacesbepp.html#a12bbc67580e3f4bb2a0299033f01818d" title="Returns the header of a message/group.">sbepp::get_header</a></code>:</p>
<div class="fragment"><div class="line">std::array&lt;std::byte, 64&gt; buf;</div>
<div class="line"><span class="keyword">auto</span> m = sbepp::make_view&lt;schema_name::messages::msg&gt;(buf.data(), buf.size());</div>
<div class="line"><span class="keyword">auto</span> header = <a class="code hl_function" href="namespacesbepp.html#a12bbc67580e3f4bb2a0299033f01818d">sbepp::get_header</a>(m);</div>
<div class="line">header.blockLength(10);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="anamespacesbepp_html_a12bbc67580e3f4bb2a0299033f01818d"><div class="ttname"><a href="namespacesbepp.html#a12bbc67580e3f4bb2a0299033f01818d">sbepp::get_header</a></div><div class="ttdeci">constexpr auto get_header(T v) noexcept -&gt; decltype(v(detail::get_header_tag{}))</div><div class="ttdoc">Returns the header of a message/group.</div><div class="ttdef"><b>Definition</b> sbepp.hpp:1514</div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="composites"></a>
Composites</h1>
<p>Typically, you need first to create a message header to check the type of the incoming message. Composite has the same form and construction approach as <a class="el" href="#messages">message</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Byte&gt;</div>
<div class="line"><span class="keyword">class </span>messageHeader : <a class="code hl_class" href="classsbepp_1_1detail_1_1composite__base.html">::sbepp::detail::composite_base</a>&lt;Byte&gt;{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// field accessors...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::array&lt;char, 64&gt; buf;</div>
<div class="line"><span class="keyword">auto</span> header = sbepp::make_view&lt;schema_name::types::messageHeader&gt;(</div>
<div class="line">    buf.data(), buf.size());</div>
<div class="line"><span class="keywordflow">if</span>(header.templateId()</div>
<div class="line">    == <a class="code hl_class" href="classsbepp_1_1message__traits.html">sbepp::message_traits&lt;schema_name::schema::messages::msg1&gt;::id</a>())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// handle msg1</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasssbepp_1_1detail_1_1composite__base_html"><div class="ttname"><a href="classsbepp_1_1detail_1_1composite__base.html">sbepp::detail::composite_base</a></div><div class="ttdoc">Base class for composites.</div><div class="ttdef"><b>Definition</b> sbepp.hpp:1647</div></div>
<div class="ttc" id="aclasssbepp_1_1message__traits_html"><div class="ttname"><a href="classsbepp_1_1message__traits.html">sbepp::message_traits</a></div><div class="ttdoc">Provides various traits/attributes of a &lt;message&gt; element.</div><div class="ttdef"><b>Definition</b> sbepp.hpp:3977</div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="groups"></a>
Groups</h1>
<p>In general, group has a container-like interface with iterators and other members you'd expect from standard container. There are two kinds of groups (message levels in general sense) which provide different interfaces:</p><ol type="1">
<li>Flat - a group which has only a fixed-size fields, no groups or data members. Such a group is represented like a random-access container similar to <code>std::vector</code>. See <code><a class="el" href="classsbepp_1_1detail_1_1flat__group__base.html" title="Base class for a flat group.">sbepp::detail::flat_group_base</a></code> for complete reference.</li>
<li>Nested - a group with has other groups or data members. Due to its nature, it's represented as a forward-only container (it's very expensive to navigate over it in a random fashion). See <code><a class="el" href="classsbepp_1_1detail_1_1nested__group__base.html" title="Base class for a nested group.">sbepp::detail::nested_group_base</a></code> for complete reference.</li>
</ol>
<h2><a class="anchor" id="autotoc_md25"></a>
Encoding</h2>
<p>Because <code>sbepp</code> provides only views, there are no functions like <code>push_back</code>, there's nothing to push. To encode a group, one needs first to set its size, then access corresponding group entries. Similar to <a class="el" href="#encoding-message">message header</a>, group header has to filled explicitly either by <code><a class="el" href="namespacesbepp.html#a7d29b37dfc83150ae34eaaf94dd4ba4c" title="Fill group header.">sbepp::fill_group_header</a></code>, <code>resize()</code> method or manually by <code><a class="el" href="namespacesbepp.html#a12bbc67580e3f4bb2a0299033f01818d" title="Returns the header of a message/group.">sbepp::get_header</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> g = msg.group_name();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set group size</span></div>
<div class="line"><span class="keyword">auto</span> group_size = 2;</div>
<div class="line"><a class="code hl_function" href="namespacesbepp.html#a7d29b37dfc83150ae34eaaf94dd4ba4c">sbepp::fill_group_header</a>(g, group_size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// fill entries</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> entry : g)</div>
<div class="line">{</div>
<div class="line">    entry.field(1);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// change size later if you need</span></div>
<div class="line">g.clear();</div>
<div class="line">g.resize(1);</div>
<div class="ttc" id="anamespacesbepp_html_a7d29b37dfc83150ae34eaaf94dd4ba4c"><div class="ttname"><a href="namespacesbepp.html#a7d29b37dfc83150ae34eaaf94dd4ba4c">sbepp::fill_group_header</a></div><div class="ttdeci">constexpr auto fill_group_header(Group g, Size num_in_group) noexcept -&gt; decltype(g(detail::fill_group_header_tag{}, num_in_group))</div><div class="ttdoc">Fill group header.</div><div class="ttdef"><b>Definition</b> sbepp.hpp:3653</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As for <a class="el" href="#encoding-message">message header</a>, group header has to be filled as early as possible because its <code>numInGroup</code> and <code>blockLength</code> are used to correctly interpret the underlying data.</dd></dl>
<h2><a class="anchor" id="autotoc_md26"></a>
Group entries</h2>
<p>Group entries have no special properties and normally are never created explicitly. See <code><a class="el" href="classsbepp_1_1detail_1_1entry__base.html" title="Base class for group entries.">sbepp::detail::entry_base</a></code> for details if you are interested.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Byte&gt;</div>
<div class="line"><span class="keyword">class </span>entry : <span class="keyword">public</span> <a class="code hl_class" href="classsbepp_1_1detail_1_1entry__base.html">sbepp::detail::entry_base</a>&lt;Byte&gt;{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// field accessors...</span></div>
<div class="line">};</div>
<div class="ttc" id="aclasssbepp_1_1detail_1_1entry__base_html"><div class="ttname"><a href="classsbepp_1_1detail_1_1entry__base.html">sbepp::detail::entry_base</a></div><div class="ttdoc">Base class for group entries.</div><div class="ttdef"><b>Definition</b> sbepp.hpp:1698</div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md28"></a>
Data members</h1>
<p>Variable-length arrays are represented using <code><a class="el" href="classsbepp_1_1detail_1_1dynamic__array__ref.html" title="Represents reference to dynamic arrays used for &lt;data&gt; elements.">sbepp::detail::dynamic_array_ref</a></code>. This type works like a reference to a vector-like type.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> d = msg.data();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(!d.empty())</div>
<div class="line">{</div>
<div class="line">    std::cout.write(d.data(), d.size());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">d.clear();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> str[]={<span class="stringliteral">&quot;hi&quot;</span>};</div>
<div class="line">d.assign(std::begin(str), std::end(str));</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md30"></a>
Fixed-size arrays</h1>
<p><code>sbepp</code> treats all <code>&lt;type&gt;</code>s with <code>length != 1</code> (including <code>0</code>) as fixed-size arrays. They are implemented in terms of <code><a class="el" href="classsbepp_1_1detail_1_1static__array__ref.html" title="Represents reference to fixed-size array.">sbepp::detail::static_array_ref</a></code> which has <code>std::span</code>-like interface.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> array = msg.array();</div>
<div class="line"> </div>
<div class="line">std::cout.write(array.data(), array.size());</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="non-array-types"></a>
Optional/required types</h1>
<p>See <code><a class="el" href="classsbepp_1_1char__t.html" title="Built-in char required type.">sbepp::char_t</a></code> and <code><a class="el" href="classsbepp_1_1char__opt__t.html" title="Built-in char optional type.">sbepp::char_opt_t</a></code> for the example of required and optional type correspondingly.</p>
<dl class="section note"><dt>Note</dt><dd>While optional/required types provide methods like <code><a class="el" href="classsbepp_1_1detail_1_1required__base.html#aa80bf5f235a4a5dfc01e606ebb883cc3" title="Checks if value is in [Derived::min_value(); Derived::max_value()] range.">sbepp::detail::required_base::in_range()</a></code> and <code><a class="el" href="classsbepp_1_1detail_1_1optional__base.html#ad2a0d48a5f8448e41a65838af24a4269" title="Checks if has value.">sbepp::detail::optional_base::has_value()</a></code>, they don't enforce any checks on the underlying value.</dd></dl>
<hr  />
<h1><a class="anchor" id="enums"></a>
Enums</h1>
<p>Enums are represented using scoped enumerations. For example:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">enum</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;enumeration&quot;</span> <span class="keyword">encodingType</span>=<span class="stringliteral">&quot;uint8&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">validValue</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;One&quot;</span>&gt;1&lt;/<span class="keywordtype">validValue</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">validValue</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;Two&quot;</span>&gt;2&lt;/<span class="keywordtype">validValue</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">enum</span>&gt;</div>
</div><!-- fragment --><p>is represented like:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> enumeration : std::uint8_t</div>
<div class="line">{</div>
<div class="line">    One : 1,</div>
<div class="line">    Two : 2</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespacesbepp.html#a0d0a0af58987f30ee37fda64c15cc316" title="Converts an enumeration to its underlying type. Equivalent to C++23 std::to_underlying()">sbepp::to_underlying</a></code>, <code><a class="el" href="namespacesbepp.html#a6b2d51af3f026b165fa40fe1d7ab19db" title="Converts enum to string.">sbepp::enum_to_string</a></code></dd></dl>
<hr  />
<h1><a class="anchor" id="sets"></a>
Sets</h1>
<p>In set representation, each <code>choice</code> has a corresponding getter and setter, for example:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">set</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;bitset&quot;</span> <span class="keyword">encodingType</span>=<span class="stringliteral">&quot;uint8&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">choice</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;A&quot;</span>&gt;0&lt;/<span class="keywordtype">choice</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">choice</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;B&quot;</span>&gt;2&lt;/<span class="keywordtype">choice</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">set</span>&gt;</div>
</div><!-- fragment --><p>is represented like:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>bitset : <span class="keyword">public</span> <a class="code hl_class" href="classsbepp_1_1detail_1_1bitset__base.html">::sbepp::detail::bitset_base</a>&lt;::std::uint8_t&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// check out base class documentation for inherited methods</span></div>
<div class="line">    using ::sbepp::detail::bitset_base&lt;::std::uint8_t&gt;::bitset_base;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// pair of getter and setter for each choice</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> A() const noexcept;</div>
<div class="line">    bitset&amp; A(const <span class="keywordtype">bool</span> v) noexcept;</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keywordtype">bool</span> B() const noexcept;</div>
<div class="line">    bitset&amp; B(const <span class="keywordtype">bool</span> v) noexcept;</div>
<div class="line">};</div>
<div class="ttc" id="aclasssbepp_1_1detail_1_1bitset__base_html"><div class="ttname"><a href="classsbepp_1_1detail_1_1bitset__base.html">sbepp::detail::bitset_base</a></div><div class="ttdoc">Base class for bitsets.</div><div class="ttdef"><b>Definition</b> sbepp.hpp:2643</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>It's important to remember that sets have value semantics to avoid such mistakes:</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// writing a message</span></div>
<div class="line">schema_name::messages::msg&lt;char&gt; m; <span class="comment">// initialize somehow</span></div>
<div class="line"><span class="comment">// does nothing!!! modifies a temporary returned by `m.bitset()`</span></div>
<div class="line">m.bitset().A(<span class="keyword">true</span>).B(<span class="keyword">true</span>);</div>
<div class="line"><span class="comment">// also does nothing, assigns to a  temporary `bool`</span></div>
<div class="line">m.bitset().A() = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// correct way</span></div>
<div class="line">m.bitset(schema_name::types::bitset{}.A(<span class="keyword">true</span>).B(<span class="keyword">true</span>));</div>
<div class="line"><span class="comment">// or, if storage was 0-initialized</span></div>
<div class="line">m.bitset(m.bitset().A(<span class="keyword">true</span>).B(<span class="keyword">true</span>));</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespacesbepp.html#aa253364a4276b55c0a157aefaa185c37" title="Visits set choices in order of their declaration.">sbepp::visit_set</a></code></dd></dl>
<hr  />
<h1><a class="anchor" id="constants"></a>
Constants</h1>
<p>Constant accessors are represented via <code>static</code> functions. Non-array constants return directly underlying value without any wrapper. Only <code>&lt;field&gt;</code> can return it as enum type. Array-like constants (strings) are represented using <code><a class="el" href="classsbepp_1_1detail_1_1static__array__ref.html" title="Represents reference to fixed-size array.">sbepp::detail::static_array_ref</a></code> like a fixed-size array.</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">composite</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;constants&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">type</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;num_const&quot;</span> <span class="keyword">primitiveType</span>=<span class="stringliteral">&quot;uint32&quot;</span></div>
<div class="line">        <span class="keyword">presence</span>=<span class="stringliteral">&quot;constant&quot;</span>&gt;123&lt;/<span class="keywordtype">type</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">type</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;str_const&quot;</span> <span class="keyword">primitiveType</span>=<span class="stringliteral">&quot;char&quot;</span></div>
<div class="line">        <span class="keyword">presence</span>=<span class="stringliteral">&quot;constant&quot;</span>&gt;<span class="keyword">hello</span> <span class="keyword">world</span>&lt;/<span class="keywordtype">type</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">composite</span>&gt;</div>
<div class="line"> </div>
<div class="line">&lt;<span class="keywordtype">sbe:message</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;message&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">field</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;enum_const&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;enumeration&quot;</span></div>
<div class="line">        <span class="keyword">presence</span>=<span class="stringliteral">&quot;constant&quot;</span> <span class="keyword">valueRef</span>=<span class="stringliteral">&quot;enumeration.Two&quot;</span>/&gt;</div>
<div class="line">&lt;/<span class="keywordtype">sbe:message</span>&gt;</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// somewhere inside `constants` class</span></div>
<div class="line"><span class="keyword">static</span> constexpr ::std::uint32_t num_const() noexcept;</div>
<div class="line">static constexpr implementation_defined_alias str_const() noexcept;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// somewhere inside `message` class</span></div>
<div class="line">static constexpr schema_name::types::enumeration enum_const() noexcept;</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="accessors"></a>
Field accessors</h1>
<p>There are multiple entities which can hold fields: messages, group entries and composites. They all provide the same interface for accessors:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Byte&gt;</div>
<div class="line"><span class="keyword">class </span>FieldContainer</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FieldRepresentation value_semantics_field();</div>
<div class="line">    <span class="keywordtype">void</span> value_semantics_field(FieldRepresentation);</div>
<div class="line"> </div>
<div class="line">    View&lt;Byte&gt; reference_semantics_field();</div>
<div class="line">};</div>
</div><!-- fragment --><p>That is, for value semantics fields there are pair of getter and setter, for reference semantics fields there is only a getter which returns a view with the same byte type as its enclosing object. When byte type is <code>const</code>-qualified, setters are not available. <br  />
 Unlike <a class="el" href="#cursor-accessors">cursor-based accessors</a>, these "normal" accessors can be used in any order.</p>
<div class="fragment"><div class="line">schema_name::messages::msg&lt;char&gt; m; <span class="comment">// init somehow</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// value semantics types</span></div>
<div class="line"><span class="keyword">auto</span> required = m.required();</div>
<div class="line">m.required(1);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> optional = m.optional();</div>
<div class="line">m.optional(2);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> enumeration = m.enumeration();</div>
<div class="line">m.enumeration(schema_name::types::my_enum::A);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> set = m.set();</div>
<div class="line">m.set(schema_name::types::my_set{}.choice(<span class="keyword">true</span>));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// reference semantics types, they all have byte type `char`</span></div>
<div class="line"><span class="keyword">auto</span> c1 = m.composite();</div>
<div class="line"><span class="keyword">auto</span> c2 = m.composite().nested_composite();</div>
<div class="line"><span class="keyword">auto</span> g = m.group();</div>
<div class="line"><span class="keyword">auto</span> d = m.data();</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="cursor-accessors"></a>
Cursor-based accessors</h1>
<dl class="section note"><dt>Note</dt><dd>The API described in this section makes sense to use only for messages of a complex structure. I recommend always to do benchmarks before using it.</dd></dl>
<p>While <a class="el" href="#accessors">normal accessors</a> can be used in any order, this is not always efficient. Consider this message:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">sbe:message</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;nested_msg&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;1&quot;</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">field</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;field1&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;uint32&quot;</span>/&gt;</div>
<div class="line">    &lt;<span class="keywordtype">field</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;field2&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;2&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;uint32&quot;</span>/&gt;</div>
<div class="line">    &lt;<span class="keywordtype">field</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;field3&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;3&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;uint32&quot;</span>/&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;<span class="keywordtype">group</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;group&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;2&quot;</span>&gt;</div>
<div class="line">        &lt;<span class="keywordtype">field</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;number&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;1&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;uint32&quot;</span>/&gt;</div>
<div class="line">        &lt;<span class="keywordtype">data</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;data3&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;2&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;varDataEncoding&quot;</span>/&gt;</div>
<div class="line">    &lt;/<span class="keywordtype">group</span>&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;<span class="keywordtype">data</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;data1&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;3&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;varDataEncoding&quot;</span>/&gt;</div>
<div class="line">    &lt;<span class="keywordtype">data</span> <span class="keyword">name</span>=<span class="stringliteral">&quot;data2&quot;</span> <span class="keyword">id</span>=<span class="stringliteral">&quot;4&quot;</span> <span class="keyword">type</span>=<span class="stringliteral">&quot;varDataEncoding&quot;</span>/&gt;</div>
<div class="line">&lt;/<span class="keywordtype">sbe:message</span>&gt;</div>
</div><!-- fragment --><p>Here, access to <code>field1/2/3</code> is still fast but access to the <code>data1</code> is not. To get its offset we need:</p><ul>
<li>read <code>blockLength</code> from <code>nested_msg</code> header to get <code>group</code>'s offset</li>
<li>read <code>numInGroup</code> from <code>group</code> header</li>
<li>read <code>blockLength</code> from <code>group</code> header</li>
<li>for each <code>group</code> entry<ul>
<li>use <code>blockLength</code> to get offset to <code>data2</code></li>
<li>read <code>data2</code> length</li>
</ul>
</li>
<li>finally, get <code>data1</code> offset</li>
</ul>
<p>Moreover, to access next <code>data2</code> all that work has to be repeated! Now imagine if there were more groups and data in that message. It's a lot of work and current compilers can't optimize <a class="el" href="#accessors">normal accessors</a> well even when everything is accessed in order.</p>
<p>The way to solve it is to access things in a forward-only manner to avoid recalculation of the next field's offset each time from the message start. In this way, after we've read the <code>group</code>, offset for <code>data1</code> is ready for free. This is the core idea behind cursor-based API.</p>
<dl class="section note"><dt>Note</dt><dd>Cursor-based API is used for forward-only access</dd></dl>
<p>A cursor (<code><a class="el" href="classsbepp_1_1cursor.html" title="Represents cursor which is used in cursor-based API. Clients should not use undocumented methods.">sbepp::cursor</a>&lt;Byte&gt;</code>) is just a pointer wrapper which is passed to field accessors as an additional parameter:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Byte&gt;</div>
<div class="line"><span class="keyword">class </span>FieldContainer</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cursor&gt;</div>
<div class="line">    FieldRepresentation value_semantics_field(Cursor&amp;&amp;);</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cursor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> value_semantics_field(FieldRepresentation, Cursor&amp;&amp;);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cursor&gt;</div>
<div class="line">    View&lt;Byte&gt; reference_semantics_field(Cursor&amp;&amp;);</div>
<div class="line">};</div>
</div><!-- fragment --><p>It's parameterized with <code>Byte</code> type which has the same meaning as for other reference semantics types. Note that it can be more <code>const</code>-qualified than the byte type of an enclosing view, setters are not available for such cursors.</p>
<p>By default, each field assumes that cursor points to the end of the previous field (or to the end of group/message header) so the offset to current field can be calculated efficiently (usually a no-op), then cursor is advanced using these rules:</p><ul>
<li><code>field</code> moves cursor up by field's size</li>
<li>last <code>field</code> moves cursor to the end of the block (calculated using <code>blockLength</code>)</li>
<li>first variable length member (<code>group</code> or <code>data</code>) of the message/entry unconditionally initializes cursor to the end of the block before using it. It means that it's possible to use uninitialized cursor with them but I don't recommend it</li>
<li><code>group</code> moves cursor to the end of group's header</li>
<li><code>data</code> moves cursor to the end of the data (<code>data() + size()</code>)</li>
</ul>
<p>Cursor has to be initialized before the first usage, it can be done via <code><a class="el" href="namespacesbepp.html#a125f1fbb9faadde1515f7822a7b6420f" title="Initializes cursor from a message/group view with the same byte type.">sbepp::init_cursor</a></code>/<code><a class="el" href="namespacesbepp.html#a399a5ac768befed2dc73396364eaa0c3" title="Initializes cursor from a message/group view with const byte type.">sbepp::init_const_cursor</a></code> or by using <code><a class="el" href="namespacesbepp_1_1cursor__ops.html#a5ea08b77415fb7c92bf38fe43f7556ac" title="Returns a wrapper which will initialize the cursor when it&#39;s used and advance after the usage.">sbepp::cursor_ops::init</a></code> or even by hand from provided pointer. Only messages and group entries provide cursor-based accessors (composites cannot contain variable-sized fields). Note that cursor-based and normal accessors return the same objects. Those object don't care how they were created. <br  />
 Here's an example of how to read the above message:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = sbepp::make_view&lt;nested_msg&gt;(buf.data(), buf.size());</div>
<div class="line"><span class="keyword">auto</span> c = <a class="code hl_function" href="namespacesbepp.html#a125f1fbb9faadde1515f7822a7b6420f">sbepp::init_cursor</a>(m);</div>
<div class="line"> </div>
<div class="line">m.field1(c);</div>
<div class="line">m.field2(c);</div>
<div class="line">m.field3(c);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> entry : m.group(c).cursor_range(c))</div>
<div class="line">{</div>
<div class="line">    entry.number(c);</div>
<div class="line">    entry.data3(c);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">m.data1(c);</div>
<div class="line">m.data2(c);</div>
<div class="ttc" id="anamespacesbepp_html_a125f1fbb9faadde1515f7822a7b6420f"><div class="ttname"><a href="namespacesbepp.html#a125f1fbb9faadde1515f7822a7b6420f">sbepp::init_cursor</a></div><div class="ttdeci">constexpr cursor&lt; byte_type_t&lt; View &gt; &gt; init_cursor(View view) noexcept</div><div class="ttdoc">Initializes cursor from a message/group view with the same byte type.</div><div class="ttdef"><b>Definition</b> sbepp.hpp:2753</div></div>
</div><!-- fragment --><p>Note that you need to use <code>cursor_range()</code> to iterate over group entries. That's because now each entry is created from the cursor.</p>
<p>Here's how compiler will see it (simplified of course):</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>* ptr = msg_start;</div>
<div class="line"><span class="keyword">auto</span> field1 = *<span class="keyword">reinterpret_cast&lt;</span>field1_type*<span class="keyword">&gt;</span>(ptr);</div>
<div class="line">ptr += <span class="keyword">sizeof</span>(field1);</div>
<div class="line"><span class="keyword">auto</span> field2 = *<span class="keyword">reinterpret_cast&lt;</span>field2_type*<span class="keyword">&gt;</span>(ptr);</div>
<div class="line">ptr += <span class="keyword">sizeof</span>(field2);</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>This approach is very efficient but the downside is that to access a field, you need to access all previous fields in their schema order. <br  />
 To provide some sort of flexibility, there are various <code><a class="el" href="namespacesbepp_1_1cursor__ops.html" title="Contains cursor wrappers which allow more precise control over its position.">sbepp::cursor_ops</a></code> helpers which can control cursor's position. Check out their documentation for examples. Here, I only want to duplicate one tricky case from <code><a class="el" href="namespacesbepp_1_1cursor__ops.html#a45f332328f49269fd0117bca732e7f36" title="Returns a wrapper which doesn&#39;t advance the cursor when it&#39;s used.">sbepp::cursor_ops::dont_move</a></code>, using cursor to write a data member:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> c = <a class="code hl_function" href="namespacesbepp.html#a125f1fbb9faadde1515f7822a7b6420f">sbepp::init_cursor</a>(msg);</div>
<div class="line"><span class="keyword">auto</span> d = msg.data(<a class="code hl_function" href="namespacesbepp_1_1cursor__ops.html#a45f332328f49269fd0117bca732e7f36">sbepp::cursor_ops::dont_move</a>(c));</div>
<div class="line">d.resize(1);   <span class="comment">// set data size somehow</span></div>
<div class="line">msg.data(c);   <span class="comment">// advance the cursor</span></div>
<div class="ttc" id="anamespacesbepp_1_1cursor__ops_html_a45f332328f49269fd0117bca732e7f36"><div class="ttname"><a href="namespacesbepp_1_1cursor__ops.html#a45f332328f49269fd0117bca732e7f36">sbepp::cursor_ops::dont_move</a></div><div class="ttdeci">constexpr detail::dont_move_cursor_wrapper&lt; Byte &gt; dont_move(cursor&lt; Byte &gt; &amp;c) noexcept</div><div class="ttdoc">Returns a wrapper which doesn't advance the cursor when it's used.</div><div class="ttdef"><b>Definition</b> sbepp.hpp:1601</div></div>
</div><!-- fragment --><p>Recall that <code>data</code> accessors by-default move the cursor to <code>data() + size()</code> so when done in a naive way:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> d = msg.data(c);</div>
<div class="line">d.resize(1);</div>
</div><!-- fragment --><p>at the time we access <code>data</code>, its length can have any value (your best hope is message buffer initialized by <code>0</code>), thus, cursor will be moved to the unknown position and its furher use is unpredictable or even UB.</p>
<p>As you can see, using cursor-based API might be tricky and requires additional care. Most schemas I saw have only a single flat group and no data, for them normal accessors work great. I recommend to use cursors only for messages with complex structure or when you did a benchmark and know for sure that you'll benefit from it. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
