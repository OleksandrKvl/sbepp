# Overview {#overview}

**sbepp** is a zero-overhead C++ implementation of [Simple Binary Encoding (SBE)](https://www.fixtrading.org/standards/sbe/).
It consists of two parts:
- `sbeppc`, schema compiler which generates header-only C++ code
- `sbepp`, header-only supporting library

## How it works

1. Compile SBE schema using [sbeppc](#sbeppc) to get C++ headers.
2. [Integrate](#integration) them into your project.
3. Link to `sbepp::sbepp` library.
4. [Use it](#representation)!

`sbepp` has two main goals:
- provide fast, direct access to SBE data
- provide convenient representation of SBE entities like types, messages, etc.

As a result, almost all types in `sbepp` are reference semantics wrappers over
memory buffer. They
never manage underlying memory in any way, only treat the data according to SBE
standard. The idea was to provide a thing similar to plain `struct` with
getters/setters and leave rest to a client. The only thing which is handled
implicitly is a schema extension mechanism, everything else must be done by
a client. For a boiler-plate things like header filling `sbepp` provides helper
utilities. Basically, all it does under the hood is offset calculation and
memory read/write.

It's worth mentioning that at the moment `sbepp` cannot generate schema
representation at run-time like other similar software.

## How it compares to RealLogic

[RealLogic](https://github.com/real-logic/simple-binary-encoding) is more like
a *platform* rather than a simple tool. It can generate code in different
languages, load schema at run-time, validate XML, etc. `sbepp` is focused
solely on generating C++ code.

Both tools generate view-like classes which don't manage memory. However,
`RealLogic` requires non-`const` `char*` buffer even for decoding, while `sbepp`
takes byte type as a template parameter and provides read-only access when it's
`const`-qualified.

The performance of the code generated by both tools is quite similar,
at least in my benchmarks I don't see a significant difference. In
compiler-explorer experiments I found that in some cases `RealLogic`'s code
results in a noticeably more assembly lines while the code generated by `sbepp`
is nearly identical to the assembly of a hand-written code.

`RealLogic` requires forward-only access when one needs to touch each field
either by reading or skipping it with explicit call. `sbepp` provides both,
random and forward-only access. Since most messages have simple structure,
random access performs just as well for them.

`RealLogic` has inconvenient [2-step process](https://github.com/real-logic/simple-binary-encoding/wiki/Cpp-User-Guide#message-header)
for message creation. `sbepp` needs only a single line to create a message
wrapper and one more call to fill message header in case of encoding.

In general, `RealLogic` provides poor C++ abstractions for SBE types and mixes
various helper functions with getters/setters. This results in message interface
being polluted with methods like `field_nameId()`, `field_nameEncodingOffset()`,
`field_nameNullValue()` along with field accessors. `sbepp` provides convenient
STL-like wrappers for each SBE entity and never mixes accessors with internal
methods so auto-suggestion in IDE shows you only schema names and nothing else.
This interface problem holds for group and fixed/variable length array
interfaces. They just don't work in a C++ way.

`RealLogic` uses exceptions to report boundary check violations (if checks are
enabled). `sbepp` uses assertions and they are supposed to be enabled only in
Debug mode.

`RealLogic` provides `iostream`-based `operator<<` with fixed formatting.
`sbepp` provides only [stringification primitives](#stringification) and
[Visit API](#visit-api) which allows clients to build their own `to_string()`
with desired format and output mechanism.

## License

Distributed under the MIT license.